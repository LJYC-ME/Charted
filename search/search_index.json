{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#integration-styles","title":"Integration Styles","text":"<ul> <li>Header include style (<code>#include &lt;charted/...&gt;</code>)</li> <li>C++20 module style (<code>import charted; import charted.json;</code>)</li> </ul> <p>Both styles share the same public API (<code>charted::route</code>, <code>charted::Json</code>).</p>"},{"location":"#header-include-example","title":"Header Include Example","text":"<pre><code>#include &lt;charted/charted.hpp&gt;\n#include &lt;charted_json/charted_json.hpp&gt;\n\nauto dynamic_route = charted::route(\"A.B[2].C\");\nauto static_route  = charted::route&lt;\"A.B[2].C\"&gt;();\n\ncharted::Json json;\njson.Set(dynamic_route, 42);\nint value = json.Get&lt;int&gt;(static_route, -1);\n</code></pre>"},{"location":"#c-module-example","title":"C++ Module Example","text":"<pre><code>import charted;\nimport charted.json;\n\nauto dynamic_route = charted::route(\"A.B[2].C\");\nauto static_route  = charted::route&lt;\"A.B[2].C\"&gt;();\n\ncharted::Json json;\njson.Set(dynamic_route, 42);\nint value = json.Get&lt;int&gt;(static_route, -1);\n</code></pre>"},{"location":"#cmake-switches","title":"CMake Switches","text":"<ul> <li><code>CHARTED_ENABLE_MODULES=OFF</code> (default): header include style only.</li> <li><code>CHARTED_ENABLE_MODULES=ON</code>: builds module bindings (<code>charted</code>, <code>charted.json</code>) on supported toolchains.</li> <li><code>CHARTED_BUILD_EXAMPLES=ON</code>: builds example targets.</li> </ul>"},{"location":"Benchmark/","title":"Benchmark","text":"<p>This page records one Release benchmark snapshot from <code>examples/overview.cpp</code>.</p>"},{"location":"Benchmark/#raw-results-release","title":"Raw Results (Release)","text":"<pre><code>=== Benchmark (lower is better) ===\nIterations: 1000000\nNote: benchmark uses flat key \"Flat\" to isolate access overhead.\nJson::Get(std::string_view): 26.72 ns/op (x1.00)\nJson::Get(dynamic route)    : 27.58 ns/op (x1.03)\nJson::Get(static route)     : 26.61 ns/op (x1.00)\nNative nlohmann find+get    : 21.97 ns/op (x0.82)\nDynamic route compile       : 27.01 ns/op (1000000 iterations, expression -&gt; tokens)\n\n=== Benchmark: Deep path A.B[2].C (lower is better) ===\nJson::Get(dynamic route)    : 50.74 ns/op (x1.00)\nJson::Get(static route)     : 53.19 ns/op (x1.05)\nNative nlohmann chained     : 45.18 ns/op (x0.89)\n\n=== Benchmark: Long route Root.Config.System.Modules[3].Pipelines[2].Stages[4].Name ===\nJson::Get(dynamic route)    : 131.40 ns/op (x1.00)\nJson::Get(static route)     : 140.88 ns/op (x1.07)\nNative nlohmann chained     : 122.30 ns/op (x0.93)\n</code></pre>"},{"location":"Benchmark/#quick-analysis","title":"Quick Analysis","text":"<ul> <li>Static route is not guaranteed to be faster in runtime lookup.</li> <li>In this run, static route is near dynamic on flat keys, and slightly slower on deeper paths.</li> <li>The main value of static route is compile-time validation of route literals.</li> <li>Dynamic route still has good ergonomics for runtime-provided paths.</li> </ul>"},{"location":"Benchmark/#reading-the-numbers","title":"Reading the Numbers","text":"<ul> <li>Treat this as a single-machine snapshot, not an absolute ranking.</li> <li>Focus on ratio (<code>x...</code>) more than raw ns/op when comparing environments.</li> </ul>"},{"location":"Benchmark/#compile-time-validation-value","title":"Compile-Time Validation Value","text":"<pre><code>constexpr auto route_ok = charted::route&lt;\"Root.Config.Modules[3].Name\"&gt;();\nstatic_assert(route_ok.IsValid(), \"route literal should be valid\");\n</code></pre> <p>Invalid route literals fail at compile time, so broken strings are caught before runtime tests.</p>"},{"location":"Integration/","title":"Integration","text":"<p>This page describes the recommended CMake integration flow for Charted.</p> <p>Charted currently does not provide <code>find_package(charted)</code> config files yet.</p>"},{"location":"Integration/#option-1-add_subdirectory","title":"Option 1: add_subdirectory","text":"<pre><code>add_subdirectory(path/to/Charted)\ntarget_link_libraries(your_target PRIVATE charted::charted)\n</code></pre>"},{"location":"Integration/#option-2-fetchcontent","title":"Option 2: FetchContent","text":"<pre><code>include(FetchContent)\n\nFetchContent_Declare(\n  charted\n  GIT_REPOSITORY https://github.com/LJYC-ME/Charted.git\n  GIT_TAG main\n)\nFetchContent_MakeAvailable(charted)\n\ntarget_link_libraries(your_target PRIVATE charted::charted)\n</code></pre>"},{"location":"Integration/#project-options","title":"Project Options","text":"<ul> <li><code>CHARTED_BUILD_EXAMPLES</code> (default: <code>ON</code>)</li> <li><code>CHARTED_ENABLE_MODULES</code> (default: <code>OFF</code>, requires CMake &gt;= 3.28)</li> </ul>"},{"location":"Integration/#mode-reminder","title":"Mode Reminder","text":"<ul> <li>Default mode is header include usage.</li> <li>Set <code>CHARTED_ENABLE_MODULES=ON</code> to build C++20 module bindings.</li> <li>In both modes, the public CMake target name is still <code>charted::charted</code>.</li> </ul>"},{"location":"Json/","title":"Json","text":"<p><code>charted::Json</code> is an adapter over <code>nlohmann::json</code>.</p>"},{"location":"Json/#basic-setget","title":"Basic Set/Get","text":"<pre><code>charted::Json json;\njson.Set(\"name\", \"Charted\");\njson.Set(\"version\", 1);\n\nstd::string name = json.Get&lt;std::string&gt;(\"name\", \"unknown\");\nint version = json.Get&lt;int&gt;(\"version\", 0);\n</code></pre>"},{"location":"Json/#route-based-access","title":"Route-Based Access","text":"<pre><code>json.Set(charted::route(\"A.B[1].C\"), 7);\nint v1 = json.Get&lt;int&gt;(charted::route(\"A.B[1].C\"), -1);\nint v2 = json.Get&lt;int&gt;(charted::route&lt;\"A.B[1].C\"&gt;(), -1);\n</code></pre>"},{"location":"Json/#parse-and-tryget","title":"Parse and TryGet","text":"<pre><code>auto parsed = charted::Json::Parse(R\"({\"pi\":3.14})\");\nif (parsed.has_value())\n{\n    auto pi = parsed-&gt;TryGet&lt;double&gt;(\"pi\");\n}\n</code></pre>"},{"location":"Route/","title":"Route","text":"<p>Route expressions support:</p> <ul> <li>Key segments: <code>A.B.C</code></li> <li>Array indices: <code>A.B[2].C</code></li> </ul>"},{"location":"Route/#dynamic-route","title":"Dynamic Route","text":"<p>Dynamic route is runtime-driven. Use it when the route comes from config, CLI, files, or user input.</p> <pre><code>auto route = charted::route(\"A.B[2].C\");\nif (route.IsValid())\n{\n    auto tokens = route.GetTokens();\n}\n</code></pre>"},{"location":"Route/#static-route","title":"Static Route","text":"<p>Static route is compile-time literal-driven. Use it when the route is fixed in code.</p> <pre><code>auto route = charted::route&lt;\"A.B[2].C\"&gt;();\n</code></pre> <p>Static routes are parsed at compile time. Invalid literals fail compilation.</p>"},{"location":"Route/#compile-time-validation","title":"Compile-Time Validation","text":"<pre><code>constexpr auto route_ok = charted::route&lt;\"Root.Config.Modules[3].Name\"&gt;();\nstatic_assert(route_ok.IsValid(), \"route literal should be valid\");\n</code></pre>"}]}